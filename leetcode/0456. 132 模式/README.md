这个题目用单调栈太巧了，爱了爱了

- 对于每个 `nums[i]`，对于其左边只需要求最小的一个值就够了，不用管其他的大小关
  系，左边只要最小的
- 对于 `nums[i]` 的右边，则需要的是**比 `nums[i]` 小的最大数**

那个如何保证？

- 对于左边的最小值，只需要先进行一次遍历，一边走一边记录最小值即可
- 对于右边呢？就算是反向遍历，也没办法很容易地得到比当前值小的最大值，这时候单
  调栈就派上用场了。选一个单调递减的栈就可以解决问题了。
